
## 2. 基础
一开始，将学习**该语言的所有基础内容**。


### 2.1 包/Packages
**每个 Go 程序都是由`包`构成的。**

**程序从 `main` 包开始运行。**

本程序通过导入路径 `"fmt"` 和 `"math/rand"` 来使用这两个包。

**按照约定，包名与导入路径的最后一个元素一致。**
例如，`"math/rand"` 包中的源码均以 `package rand` 语句开始。

**注意**：此程序的运行环境是固定的，因此 `rand.Intn` 总是会返回相同的数字。
（要得到不同的数字，需为生成器提供不同的种子数，参见 `rand.Seed`。
练习场中的时间为常量，因此你需要用其它的值作为种子数。）


### 2.2 导入/Imports
此代码**用`圆括号`组合了导入**，这是 **“分组”形式的导入语句**。

当然你也可以编写多个导入语句，例如：
```go
import "fmt"
import "math"
```

不过使用**分组导入语句**是更好的形式。


### 2.3 导出名/Exported names
在 Go 中，如果一个**名字以`大写字母`开头**，那么它就是**已导出**的。
例如，`Pizza` 就是个已导出名，`Pi` 也同样，它导出自 `math` 包。

`pizza` 和 `pi` 并未以大写字母开头，所以它们是`未导出`的。

**在导入一个`包`时，只能引用其中已导出的名字。
任何“未导出”的名字在该包外均无法访问。**

执行代码，`观察错误输出`。
```go
prog.go:9:14: cannot refer to unexported name math.pi
prog.go:9:14: undefined: math.pi
```

然后将 `math.pi` 改名为 `math.Pi` 再试着执行一次。


### 2.4 函数/Functions
函数可以没有参数或接受多个参数。

在本例中，`add` 函数接受两个 `int` 类型的参数。

**注意，`类型`在`变量名`之后。**

（参考这篇[关于 Go 语法声明](http://blog.go-zh.org/gos-declaration-syntax)的文章，
了解**这种类型声明形式出现的原因**。）


### 2.5 函数（续）/Functions continued
当`连续两个或多个函数的`已命名`形参类型相同`时，除最后一个类型以外，其它都可以省略。

在本例中，
```go
x int, y int
```

被缩写为
```go
x, y int
```


### 2.6 多值返回/Multiple results
**`函数`可以返回`任意数量的返回值`。**

`swap` 函数返回了两个字符串。


### 2.7 命名返回值/Named return values
**Go 的返回值可被命名，它们会被视作`定义在函数顶部的变量`。**

返回值的名称应当具有一定的意义，它可以作为文档使用。

没有参数的 `return` 语句返回已命名的返回值，也就是 "直接" 返回。

`直接返回语句`应当仅用在下面这样的短函数中。在长的函数中它们会`影响代码的可读性`。


### 2.8 变量/Variables
`var` 语句用于`声明一个变量列表`，跟函数的参数列表一样，类型在最后。

就像在这个例子中看到的一样，`var` 语句可以出现在`包或函数`级别。


### 2.9 变量的初始化/Variables with initializers
**变量声明**可以包含初始值，每个变量对应一个。

**如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型(类型推导)。**


### 2.10 短变量声明/Short variable declarations
在函数中，简洁赋值语句 `:=` 可在类型明确的地方代替 `var` 声明。

函数外的每个语句都必须以关键字开始（`var`, `func` 等等），因此 `:=` 结构不能在函数外使用。


### 2.11 基本类型/Basic types
Go 的基本类型有
```go
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
    // 表示一个 Unicode 码点

float32 float64

complex64 complex128
```

本例展示了几种类型的变量。同导入语句一样，变量声明也可以“分组”成一个语法块。

`int`, `uint` 和 `uintptr` 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。
当你需要一个整数值时应使用 `int` 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。


### 2.12 零值/Zero values
没有明确初始值的变量声明会被赋予它们的**零值**。

零值是：
> 数值类型为 `0`，
>
> 布尔类型为 `false`，
>
> 字符串为 `""`（空字符串）。


### 2.13 类型转换/Type conversions
表达式 `T(v)` 将值 `v` 转换为类型 `T`。

一些关于数值的转换：
```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
```

或者，更加简单的形式：
```go
i := 42
f := float64(i)
u := uint(f)
```

与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换。
试着移除例子中 `float64` 或 `uint` 的转换看看会发生什么。
```go
prog.go:10:32: cannot use x * x + y * y (type int) as type float64 in argument to math.Sqrt
prog.go:11:6: cannot use f (type float64) as type uint in assignment
```


### 2.14 类型推导/Type inference
在声明一个变量而不指定其类型时（即使用不带类型的 `:=` 语法或 `var =` 表达式语法），
**变量的类型由`右值推导`得出**。

当右值声明了类型时，新变量的类型与其相同：
```go
var i int
j := i // j 也是一个 int
```

不过当右边包含`未指明类型的数值常量`时，
新变量的类型就可能是 `int`, `float64` 或 `complex128`，这取决于常量的精度：
```go
i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
```

尝试修改示例代码中 `v` 的初始值，并观察它是如何影响类型的。


### 2.15 常量/Constants
常量的声明与变量类似，只不过是使用 `const` 关键字。

常量可以是字符、字符串、布尔值或数值。

常量不能用 `:=` 语法声明。


### 2.16 数值常量/Numeric Constants
数值常量是高精度的**值**。

**一个`未指定类型的常量`由`上下文`来决定其类型。**

再尝试一下输出 `needInt(Big)` 吧。

（`int` 类型最大可以存储一个 64 位的整数，有时会更小。）
（`int` 可以存放最大64位的整数，根据平台不同有时会更少。）


### 2.17 恭喜！
你已经完成了本课程！

你可以返回[模块](https://tour.go-zh.org/list)列表看看接下来要学什么，
或者继续[后面的课程]。

