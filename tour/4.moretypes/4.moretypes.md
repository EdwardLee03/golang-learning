
## 4. 更多类型：struct、slice 和 映射


### 4.1 指针/Pointers
Go 拥有指针。**指针保存了值的内存地址。**

类型 `*T` 是指向 `T` 类型值的**指针**。其**零值**为 `nil`。
```go
var p *int
```

**`&` 操作符会生成一个指向其操作数的指针。**
```go
i := 42
p = &i
```

**`*` 操作符表示指针指向的底层值。**
```go
fmt.Println(*p) // 通过指针 p 读取 i
*p = 21         // 通过指针 p 设置 i
```

这也就是通常所说的“**间接引用**”或“**重定向**”。

与 C 不同，Go 没有指针运算。


### 4.2 结构体/Structs
一个结构体（`struct`）就是一个**字段的集合**。(一个对象，还包含行为方法)


### 4.3 结构体字段/Struct Fields
结构体字段使用**点号**来访问。


### 4.4 结构体指针/Pointers to structs
**结构体字段**可以通过**结构体指针**来访问。

如果我们有一个指向结构体的指针 `p`，那么可以通过 `(*p).X` 来访问其字段 `X`。
不过这么写太啰嗦了，所以语言也允许我们使用**隐式间接引用**，直接写 `p.X` 就可以。


### 4.5 结构体文法/Struct Literals
**结构体文法**通过直接列出字段的值来新分配一个结构体。

使用 `Name:` 语法可以仅列出部分字段。（字段名的顺序无关。）

特殊的前缀 `&` 返回一个指向结构体的指针。


### 4.6 数组/Arrays
**类型 `[n]T` 表示拥有 `n` 个 `T` 类型的值的数组。**

表达式
```go
var a [10]int
```
会将变量 `a` 声明为拥有有 10 个整数的数组。

`数组的长度是其类型的一部分，因此数组不能改变大小。`
这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。


### 4.7 切片/Slices
每个数组的大小都是固定的。而**切片则为数组元素提供动态大小的、灵活的视角。
在实践中，`切片`比数组更常用。**

类型 `[]T` 表示一个元素类型为 `T` 的切片。

**切片通过两个下标来界定**，即一个上界和一个下界，二者以冒号分隔：
```go
a[low : high]
```
它会选择一个半开区间，包括第一个元素，但排除最后一个元素。

以下表达式创建了一个切片，它包含 `a` 中下标从 1 到 3 的元素：
```go
a[1:4]
```


### 4.8 切片就像数组的引用/Slices are like references to arrays
**切片并不存储任何数据，它只是描述了底层数组中的一段。**

**更改切片的元素会修改其底层数组中对应的元素。**

与它共享底层数组的切片都会观测到这些修改。


### 4.9 切片文法/Slice literals
**切片文法**类似于没有长度的数组文法。

这是一个数组文法：
```go
[3]bool{true, true, false}
```

下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：
```go
[]bool{true, true, false}
```


### 4.10 切片的默认行为/Slice defaults
在进行切片时，你可以利用它的默认行为来忽略上下界。

**切片下界的默认值为 0，上界则是该切片的长度。**

对于数组
```go
var a [10]int
```

来说，以下切片是等价的：
```go
a[0:10]
a[:10]
a[0:]
a[:]
```


### 4.11 切片的长度与容量/Slice length and capacity
切片拥有 **长度** 和 **容量**。

**切片的长度**就是**它所包含的元素个数**。

**切片的容量**是从它的第一个元素开始数，到其底层数组元素末尾的个数。

切片 `s` 的长度和容量可通过表达式 `len(s)` 和 `cap(s)` 来获取。

你可以**通过重新切片来扩展一个切片，给它提供足够的容量。**
试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。


### 4.12 nil 切片/Nil slices
**切片的零值**是 `nil`。

**nil 切片的长度和容量为 0 且没有底层数组。**


### 4.13 用 make 创建切片/Creating a slice with make
切片可以用**内建函数** `make` 来创建，这也是你创建动态数组的方式。

`make` 函数会分配一个元素为零值的数组并返回一个引用了它的切片：
```go
a := make([]int, 5)  // len(a)=5
```

要指定它的容量，需向 `make` 传入第三个参数：
```go
b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
```


### 4.14 切片的切片/Slices of slices
切片可包含任何类型，甚至包括其它的切片。


### 4.15 向切片追加元素/Appending to a slice
为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 `append` 函数。
[内建函数的文档](https://go-zh.org/pkg/builtin/#append)对此函数有详细的介绍。
```go
func append(s []T, vs ...T) []T
```

`append` 的第一个参数 `s` 是一个元素类型为 `T` 的切片，
其余类型为 `T` 的值将会追加到该**切片的末尾**。

`append` 的结果是一个包含原切片所有元素加上新添加元素的切片。

当 `s` 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。
返回的切片会指向这个新分配的数组。

（要了解关于切片的更多内容，请阅读文章
[Go 切片：用法和本质](https://blog.go-zh.org/go-slices-usage-and-internals)。）


### 4.16 Range
`for` 循环的 `range` 形式可遍历**切片或映射**。

当使用 `for` 循环遍历切片时，每次迭代都会返回两个值。
第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。


### 4.17 range（续）/Range continued
可以将下标或值赋予 `_` 来忽略它。

若你只需要索引，去掉 `value` 的部分即可。


### 4.18 练习：切片/Exercise: Slices
实现 `Pic`。
它应当返回一个长度为 `dy` 的切片，其中每个元素是一个长度为 `dx`，元素类型为 `uint8` 的切片。
当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。

图像的选择由你来定。几个有趣的函数包括 `(x+y)/2`, `x*y`, `x^y`, `x*log(y)` 和 `x%(y+1)`。

（提示：需要使用循环来分配 `[][]uint8` 中的每个 `[]uint8`；
请使用 `uint8(intValue)` 在类型之间转换；你可能会用到 `math` 包中的函数。）


### 4.19 映射/Maps
**映射**将键映射到值。

**映射的零值**为 `nil`。`nil` 映射既没有键，也不能添加键。

`make` 函数会返回给定类型的映射，并将其初始化备用。


### 4.20 映射的文法/Map literals
映射的文法与结构体相似，不过必须有**键名**。


### 4.21 映射的文法（续）/Map literals continued
若顶级类型只是一个类型名，你可以在文法的元素中省略它。


### 4.22 可变的映射/Mutating Maps
在映射 `m` 中插入或修改元素：
```go
m[key] = elem
```

获取元素：
```go
elem = m[key]
```

删除元素：
```go
delete(m, key)
```

通过双赋值检测某个键是否存在：
```go
elem, ok = m[key]
```

若 `key` 在 `m` 中，`ok` 为 `true`；否则，`ok` 为 `false`。

若 `key` 不在映射中，那么 `elem` 是该映射元素类型的零值。

同样的，当从 映射 中读取某个不存在的键时，结果是 映射 的元素类型的零值。

**注**：若 `elem` 或 `ok` 还未声明，你可以使用**短变量**声明：
```go
elem, ok := m[key]
```


### 4.23 练习：映射/Exercise: Maps
实现 `WordCount`。它应当返回一个映射，其中包含字符串 `s` 中每个“单词”的个数。
函数 `wc.Test` 会对此函数执行一系列测试用例，并输出成功还是失败。

你会发现 [strings.Fields](https://go-zh.org/pkg/strings/#Fields) 很有帮助。


### 4.24 函数值/Function values
**函数也是值**。它们可以像其它值一样传递。

**函数值可以用作函数的参数或返回值。**


### 4.25 函数的闭包/Function closures
Go 函数可以是一个闭包。
**闭包是一个函数值，它引用了其函数体之外的变量。**
该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。

例如，函数 `adder` 返回一个闭包。每个闭包都被绑定在其各自的 `sum` 变量上。


### 4.26 练习：斐波纳契闭包/Exercise: Fibonacci closure
让我们用函数做些好玩的事情。

实现一个 `fibonacci` 函数，它返回一个**函数（闭包）**，
该闭包返回一个[斐波纳契数列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97)
\`(0, 1, 1, 2, 3, 5, ...)\`。


### 4.27 恭喜！/Congratulations!
你已经完成了本课程！

你可以返回[模块列表](https://tour.go-zh.org/list)看看接下来学习什么，
或者继续[后面的课程](https://tour.go-zh.org/methods/1)。

